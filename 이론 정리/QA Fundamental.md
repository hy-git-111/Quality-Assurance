[마크다운 가이드] https://www.markdownguide.org/cheat-sheet/

# SW 품질
: 기능, 비기능, 기타 도메인 요구사항 등을 충족하는 정도

<br/>

# SW 품질의 주요 요소

* 기능 적합성
* 성능 효율성
* 호환성
* 사용성
* 신뢰성
* 보안성
* 유지보수성
* 이식성

<br/>

# SW 검증 항목

* 기능성
* 성능
* 보안
* 사용성

<br/>

# SW 품질 향상을 위한 방법

* 코드 리뷰  
    * 코드 검토를 통해 오류를 사전에 제거
        > <span style="color:darkgray">**일반적으로 기업에서는 개발자들이 담당**</span>

* 테스팅
    * 기능, 성능, 보안을 포함한 다양한 테스트 실행
    * 서버 테스트는 개발자가 거의 수행함   

* 품질 관리 프로세스
    * ISO/IEC 25010 국제 표준 준수  

* 사용자 피드백 반영
    * 실 사용자의 의견을 통해 품질 개선

<br/>

# 품질 향상을 위한 업무

* Testing
    * 요구사항 충족 확인을 위해 설계된 활동

* QC, Quality Control
    * 결함 탐지, 수정을 위해 테스트 및 제품 품질 평가
    * 교정적(문제 발생 후 수정)

* QA, Quality Assurance  
    * 소프트웨어 개발 과정 전반에서 품질 목표를 설정하고 이를 달성하기 위한 활동
    * 프로세스 설계, 표준 준수 검토, 절차 개선
    * CL, 테스트 시나리오 작성 업무
    * 예방적

* QM, Quality Management
    * 조직 차원에서 제품 품질 보장을 위한 전체 프로세스와 정책, 절차 수립 및 실행

        > <span style="color:darkgray">**TC 설계 방식  
            개발자 : 기능 기반 설계  
            QA : 요구사항 기반 설계**</span>

<br/>

# SW Testing 7가지 원리

* 테스트는 결함의 존재를 밝히는 활동이다.
* 오류는 어디에나 존재한다.
* 완벽한 테스팅은 불가능하다.
* 테스트는 초기에 해야한다.
* 파레토의 법칙(전체 결과의 80%가 전체 원인의 20%에서 발생한다.)
* 테스팅은 정황에 따라 다르다.
* 오류 부재의 궤변

<br/>

# 테스트 기술의 발전 단계

1. 디버깅 위주의 시대
    * 테스트와 디버깅의 구분이 없음  
    * 테스트를 "결함 제거를 돕는 활동"으로 인식

2. 증명 위주의 시대
    * 소프트웨어가 요구사항을 만족시키는지 증명  
    * 디버깅 활동과 결함 발견, 위치 파악, 수정 과정과 연계됨

3. 파괴 위주의 시대
    * 테스트를 결함을 발견하는 활동으로 구분
    * 디버깅을 결함의 위치를 파악하고 수정하는 활동으로 인식

4. 평가 위주의 시대
    * 소프트웨어 개발 프로세스 전반에 테스트가 흡수되고 통합된 상태
    * 검토 활동의 가치가 인식됨
    * 테스트 개념이 확장됨
    * 요구사항, 디자인, 구현과정 등 개발 활동 전반에서 결함 발견

5. 예방 위주의 시대
    * CMM, TMM 레벨 5 최적화 단계 반영
    * 요구사항, 디자인, 구현과정 등 개발 활동 전반에서 결함 발견

<br/>

# 소프트웨어 테스트 수명주기(STLC)

## 소프트웨어 테스트 단계

1. 요구사항 분석
    * 기능 명세서, 기획서 등 명세를 바탕으로 요구사항 검토 및 테스트 조건 도출, NFR(비기능 요구사항) 정의

        > <span style="color:darkgray">**개발팀은 요구사항 정의서를 통해 테스트 대상이 정의됨   
        이후 개발작업에서 테스트를 고려하여 설계함  
        따라서 개발에서는 별도의 계획이나 분석이 필요하지 않음**</span>

2. 테스트 계획  
    * 테스트 범위와 유형 선정
    * 목표와 전략 설정    
    * 자원 및 일정 관리
    * 테스트 환경 및 데이터 준비 계획
    * 프로젝트 리스크 평가 및 우선순위 선정이 필수적임

3. 테스트 설계, 구현
    * 테스트 분석을 바탕으로 Test Case, Test Data, Test Scenario 구체화

4. 테스트 환경 준비

5. 테스트 실행
    * 소프트웨어의 안정성과 신뢰성을 확보하는 핵심 단계
    * 예상 결과와 실제 결과 비교, 확인 테스트 수행

        > <span style="color:darkgray">**개발에서는 JUnit 등의 툴을 사용하여 코드 작성과 동시에 테스트 진행**</span>

6. 테스트 종료
    * 테스트 종료 기준 충족 여부 확인
    * 최종 보고서 작성
    * 회고를 통해 프로세스의 효율성/효과성을 평가하고 개선 방안 도출

<br/>

## 요구사항 분석

* 요구사항의 종류
    * 기능 요구사항  
        * 기능에 대한 우선순위가 중요함
        * 기능 정의서 : 소프트웨어가 수행해야하는 것에 대한 명세(기능, 입력, 출력 정의)

    * 비기능 요구사항  
        * 시스템 성능, 보안, 확장성 등 품질 특성 정의

    * 도메인 요구사항
        * 특정 산업이나  비즈니스 도메인에 특화된 요구사항
        * 산업 규정, 관련 법률 등

            > <span style="color:darkgray">**기능 요구사항을 받으면  
            보안 > 프레임워크 > 자원 > 도메인 순으로 고려하여 개발 작업 진행**</span>

<br/>

## 테스트 계획

### 테스트 목표 수립

* 결함 발견, 요구사항 충족 여부 확인, 사용자 만족도 향상 등을 포함함  
* 코어기능(비즈니스 핵심 기능) > 보안 순으로 우선순위가 높음

<br/>

### 테스트 전략 수립

* 전략 수립 유형
    * 위험 기반 접근법
    : 주요 리스크를 우선적으로 테스트

    * 요구사항 기반 접근법
    : 소프트웨어 요구사항에 따라 테스트 설계 

    * 탐색적 접근법
    : 정해진 케이스 외에도 결함 가능성이 높은 영역 탐색

    * 자동화 접근법
    : 반복적인 작업을 자동화하여 효율성 극대화

        * 테스트 스크립트 툴  
            * Java  
            * JavaScript
            * Python

        * 테스트 도구
            * Selenium
            : 웹 애플리케이션과 상호작용하여 브라우저 직접 조작
            * JMeter
            : 성능, 부하 테스트, 웹 애플리케이션, 서버, DB, API 성능 테스트
            * Postman, Appium

<br/>
       
* 리스크 평가 단계
    1. 리스크 식별
        : 결함, 성능, 일정, 자원 등

    2. 리스크 평가
        : Impact(영향도), Likelihood(발생 가능성) 판단

    3. 대응 방안 수립

    4. 리스크 모니터링

* 리스크 대처 방안  
    : 회피, 감소, 수용, 이전(타부서나 외부 업체와 분담)

<br/>

### 테스트 자원 분배 및 일정 계획

* 테스트 범위와 목표에 따라 자원을 사전에 정의
    * 브룩스의 법칙(Brook's Law)  
    : 늦어진 프로젝트에 인력을 추가하면 프로젝트가 더 늦어진다.

        > <span style="color:darkgray">**병렬화의 한계 발생  
        커뮤니케이션 복잡성 증가, 훈련 비용, 인수인계 시간 필요 등**</span>

<br/>

* 일정 계획의 요소
    * 테스트 일정 설정  
    : 시작 및 종료 시점 정의

    * 작업 분할  
    : 각 테스트 간계의 소요시간 예측 및 분배

    * 리스크 관리  
    : 여유 시간 설정

    * 의사소통 계획  
    : 일정 공유, 협업을 위한 체계 마련

<br/>

## 테스트 설계, 구현

* Test Condition
    * 검증 상황, 입력값, 정상동작 판단 기준
    * 테스트 우선순위 선정에 활용됨

* Test Condition 도출 순서
    1. 요구사항 분석
    2. 리스크가 높은 부분 확인

        > <span style="color:darkgray">**코어 기능 > 복잡성이 높음  
        코어 기능 > 구현에 시간 자원이 많이 소요  
        따라서 코어 기능의 리스크가 높을 확률이 큼!**</span>

    3. 사용자 입장에서의 도출
    4. 최대/최솟값 검증
        
* Test Case
    * 구성
        : 분류, 입력값, 수행 절차, 기대 결과, 수행 결과

* Test Data
    * 테스트 실행 시 필요한 입력값과 환경을 구성하는 자료
        * 실제 운영 데이터
        * 모의 데이터(보안 이슈가 있는 경우)
        * 경계값
        * 비정상 데이터

<br/>

## 테스트 환경 준비

* 테스트 환경의 종류(각 환경마다 사용하는 DB가 다름)
    * Local Server     
    : 개발자 PC에 설치된 개발 및 테스트 환경

    * Dev Server  
    : "서버" 개발 환경, 기능 중심의 코드 블록을 통합하여 테스트 수행

    * Staging Server  
    : 운영과 동일한 환경  
    운영에서 사용하는 DB를 사용하여 테스트 진행(비기능 테스트 포함)

    * Production Server      
    : 운영 환경, 라이브 서버, 실제 서버를 위한 운영 환경

<br/>

* 테스트 환경 설정의 주요 요소
    * 하드웨어 설정  
    : CPU, 메모리, 디스크 공간 등

    * 소프트웨어 구성  
    : OS, DB, App 설치 및 설정

    * 네트워크 환경  
    : 네트워크 속도와 대역폭, 지연 시간 등을 실제 환경과 비슷하게 설정하여 반영  
    온프레미스(On-premise)/클라우드 서비스 사용 고려
         
    * 테스트 데이터 준비

    * 테스트 환경 최적화

<br/>

## 테스트 실행

* 테스트 실행 방법론의 유형
    * 수동 테스트  
    : 테스터가 직접 케이스 수행

    * 자동화 테스트  
    : 반복적이고 시간이 많이 소요되는 작업을 자동화 도구로 실행  
    e.g. 성능 모니터링, 리그레션 테스트

    * 탐색적 테스트  
    : 경험과 직관을 기반으로 수행

    * 스모크 테스트  
    : 주요 기능이 정상적으로 동작하는지 확인하는 테스트  
    자동화를 통해 초기 테스트 단계에서 일정 수준의 커버리지 확보 가능

<br/>

* 결함 기록
    * 품질 보증 프로세스의 핵심 단계 중 하나
    * 우선순위, 심각도, 해결을 위한 복잡도에 따라 결함이 분류됨
    * 항목  
    : ID, 요약, 사전 조건, 재현 단계, 우선순위 및 심각성

<br/>

* 테스트 모니터링 및 제어
    * 테스트 진행 현황 추적  
    * 테스트 상태 추적 지표
        * 테스트 수행률
        * 테스트 커버리지
        * 결함 분포(기능/성능/UI 결함 등)
        * 결함 수정 상태
        * 일정 준수율

    > <span style="color:darkgray">**테스트 커버리지가 90%이고,  
    나머지 10% 기능의 우선순위가 낮다면 잘 수행된 테스트라고 평가 가능함  
    (평균 85% ~ 90%)**</span>
    
<br/>

* 테스트 결과 분석
    * 결함 데이터 분석
    : 결함 수, 종류, 심각도

    * 테스트 커버리지 평가
    : 테스트 누락 확인

    * 재테스트 수행 여부 평가

    * 품질 개선 제안
    : 추가 테스트 제안, 코드 수정

    * 최종 평가
    : 소프트웨어가 기대 수준에 적합한지 평가

<br/>

* 테스트 결과 보고서
    * 구성
    : 테스트 요약, 결함 현황, 테스트 상태, 추천 사항(품질 개선을 위한 QA 의견)

<br/>

## 테스트 종료
* 테스트 종료 평가 기준
    1. 기능 기반
        * 제품 초기에 중요한 종료 기준
        * 주요 기능의 정상 동작 여부 평가
        * 핵심 기능이 오류 없이 동작하면 테스트 종료
    
    2. 결함
        * 잔여 결함의 심각도 고려

    3. 커버리지

    4. 시간
        * 기간 내 목표한 검증이 완료되었는지 평가하여 테스트 종료

    5. 리스크
        * 리스크 평가 결과를 바탕으로 테스트 종료 여부 결정

<br/>

* 테스트 완료 보고서
    * 테스트 범위, 결함, 테스트 상태, 개선 사항 포함

<br/>

* 회고
    * 테스트 프로세스의 효율성과 효과성 증진
    * 향후 프로젝트에 적용할 교훈 도출
    * 성과 평가, 문제 분석, 지식 공유, 지속적인 개선

    > IT업계에서 중요한 요소!

<br/>

# 테스트 방식의 분류

## 정적/동적 테스팅
* 정적 테스팅
    * 리뷰
    * 정적 분석

* 동적 테스팅
    * 블랙박스 테스트  
    : 명세 기반, 소스코드를 참고하지 않고 TC 설계

    * 화이트박스 테스트  
    : 구조 기반, 소스코드와 내부 구조를 바탕으로 TC 설계

## 테스트 레벨
* 단위 테스트(Unit Test)
    * 함수, 메서드 단위의 단일 기능 테스트
        * 함수 : 특정 작업을 수행하는 코드, 재사용과 가독성 향상을 위해 사용(호출 객체 X)
        * 메서드 : 클래스 내부에 정의한 함수(호출 객체 O)

    * 독립적 TC 작성을 통해 다른 테스트에 영향을 받지 않도록 수행
    * 유지보수 단계에서는 코드가 변경될 떄 TC를 함께 수정해 오류 방지

<br/>

* 통합 테스트(Itegration Test)
    * 모듈 간 연결 확인으로 시스템 전체의 안정성 확보
    * 통합테스트 전략
        * 하향식 접근법(Top-down)
        * 상향식 접근법(Bottom-up)
        * 샌드위치 접근법(Sandwich)
        : 시스템을 각 계층으로 나누어 개발함 > 계층별로 나누어 테스트 수행
        * 비 점진적 전략(Big Band)

    * 통합 테스트 주요 활동
        * 인터페이스 검증  
        : 모듈 간 데이터의 전달/교환 확인
        API 호출 확인
        
        * 통합 시나리오 설계  
        : 전체 기능 흐름을 따라 테스트를 단계적으로 수행할 수 있도록 설계  
        코드단에서는 데이터를 주는 순서 지정

        * API 테스트  
        : 기능 간 API 호출(요청과 응답)이 올바르게 이루어지는지 검증
        잘못된 데이터를 받으면 오류를 인지할 수 있는지도 확인 필요

        * 결과 분석  
        : 각 모듈이 서로 연결된 상태에서 제대로 작동하는지 확인하고 오류를 찾아냄

<br/>

* 시스템 테스트(System Test)
    * SW를 하나의 완성된 시스템으로 보고, 모든 기능과 성능이 정상적으로 작동하는지 확인
    * 기능적 요구사항과 비기능적 요구사항 모두를 점검

<br/>

* 인수 테스트(Acceptance Test)
    * 비즈니스 관점에서의 동작 확인
        * 알파 테스트
        : 소규모 그룹의 의견 수집

        * 베타 테스트
        : 공개적으로 발표되는 경우가 많음
        평균 6개월 정도 지속

<br/>

* End to End 테스트(E2E Test)  
    * 웹 통신을 기반으로한 테스트  
    * 기능 관점에서, 시스템의 시작부터 끝까지 전체 흐름을 확인  

[추가 학습 자료] https://hyeon9mak.github.io/acceptance-test-vs-e2e-test/

<br/>

## 테스트 유형
* 기능 테스트
    * 입력값과 출력값 비교
    * 비정상 시나리오를 포함한 시뮬레이션 진행

<br/>

* 비기능 테스트
    * 성능 테스트  
    : 응답 시간, 처리량, 자원 사용량 측정

    * 부하 테스트  
    : 유저의 수와 초당 API 요청 등을 증가시켜 시스템 내구성을 테스트하고 결과를 모니터링  
    "애플리케이션의 한계"를 찾는 테스트

    * 스트레스 테스트  
    : 시스템이 과부하 상태일 때 서버가 다운되지 않고 에러를 처리하여, 시스템이 안정적으로 복구가 되는지 확인

    * 복구 테스트  
     : 서버 다운 후 자동 복구가 되는지 확인

        <span style="color:darkgray">**스트레스 테스트와 복구 테스트는 결이 비슷해서 함께 진행된다**</span>

    * 보안 테스트 : 보안 공격으로 부터 안전한지 확인

    * 사용성 테스트 : 인터페이스가 직관적이고 사용하기 편한지 확인

[추가 학습 자료] https://seongwon.dev/ETC/20220919-%EC%84%B1%EB%8A%A5%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%B6%80%ED%95%98%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%8A%A4%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%9E%80/

<br/>

* 구조적 테스트
    * 로직의 흐름을 기반으로 오류 확인
    * 주로 조건문과 반복문의 실행으로 논리적 결함 발견

<br/>

* 회귀 테스트
    * 기능의 확장 등으로 인한 코드 변경 후, 기존 기능이 제대로 작동하는지 확인
    * 사이드 이펙트의 영향이 있는지 확인

<br/>

* 탐색적 테스트
    * 새로운 기능이 추가되거나 초기 단계에서 효과적
    * 예기치 못한 결함을 빠르게 해결할 수 있음

<br/>

* 유효성 테스트(Validation Testing)
    * 올바른 제품을 만들었는지 확인
    * 개발 후반, 실제 사용 환경에서 수행
    * SW가 요구사항을 충족하는지 확인
    * 블랙박스 테스트 기법 사용

<br/>

* 확인 테스트(Verification Testing)
    * 제품을 올바르게 만들었는지 확인
    * SW가 정확히 구현되었는지 확인
    * 개발 초반, 설계 및 구현 단계에서 수행
    * 화이트박스 테스트 기법 사용

<br/>

# 테스트 설계 기법
* 테스트 설계 기법 선택 기준
    * SW 복잡성 고려
    
        > <span style="color:darkgray">**복잡성 관리가 중요한 시스템에서는  
        코드와 구조를 분석하는 기법이 유용함**</span>
    
    * 목표 및 리스크 파악
    * 리소스 평가
    * 요구사항 명확성 평가

## 명세 기반 테스트
* 동등 분할
    * 입력값을 분류하여 각 구간별 대표값을 테스트 입력값으로 사용
    * 입력값 구조가 단순할때 사용
    * 복잡한 관계 검증에 부적합

* 경계값 분석
    * 입력값의 경계값을 중심으로 테스트
    * 복잡한 시스템에 부적합

* 상태전이
    * 특정 입력에 따라 상태가 어떻게 바뀌는지를 확인
    * 데이터 흐름을 인식하여 분기 오류(논리적 오류)를 찾을 수 있음

* 결정 테이블
    * 입력 조건이 다양할 때 사용

## 구조 기반 테스트
: 프로그램 설계도를 바탕으로 논리적 오류 확인

* 제어 흐름 기반
    * 조건문, 반복문 등을 기반으로 테스트 설계
    * 모든 실행 경로가 한 번 이상 테스트되어야 함

* 데이터 흐름 기반
    * 변수의 정의와 사용 간의 관계를 검증
    * 변수가 올바르게 초기화되고, 사용 후 예상대로 변경되지 않았는지 확인

    잘못된 변수 선언의 예
    ```
    # Javascript 변수 선언 예시

    let a; // 초기화 x(= 초기값 지정 x), 코드 실행 시 오류 발생
    ```

    변수가 올바르게 초기화가 되지 않은 예
    ```
    # 변수명은 수치를 뜻하지만, 값의 형식은 숫자가 아닌 경우

    amount = "문자열"
    ```

    데이터 일관성이 보장되지 못한 예
    ```
    # 금액의 합계를 구하는 코드

    amount = 1000   # 숫자
    name = "김혜영" # 문자열
    amount + name = total   # 숫자와 문자열 더하기 연산 수행
    ```

* 코드 커버리지
    * Line Coverage
    : 모든 구문을 한 번 이상 실행

    * Branch Coverage
    : 모든 분기 "결과값"이 한번씩 나오도록 테스트

    * Condition Coverage
    : 조건식의 "개별 조건"이 참/거짓이 한 번씩 나오도록 테스트

    * 다중 조건 커버리지
    : 다중 조건문과 반복문이 포함되었을 때, 모든 조건 조합의 경로 테스트

    * Path Coverage
    : 모든 경로 테스트
<br/>

## 경험 기반 테스트
: 테스터의 숙련도와 결함 탐지 속도 비례

* 탐색적 테스트
    * 경험과 직관 활용

* 오류 추정
    * 과거 경험과 시스템 지식을 바탕으로 결함을 예측하여 테스트
    * 새로운 유형의 오류 확인이 어려움

* 체크리스트 기반 테스트
    * 주요 기능, 요구사항, 표준 규격 등의 테스트에 사용
    * 예외상황 탐지가 어려움

<br/>

# SDLC 단계별 QA의 역할
## QA vs QC
* QA  
: 개발 과정 자체를 개선하여 품질 문제를 사전에 방지

    * 품질 보증 프로세스 설계 및 관리
    * 프로세스 개선 활동을 통해 결함 예방
    * 테스트 활동 계획 및 효율성 검증

<br/>

* QC  
: 완성된 제품의 결함을 발견

    * 테스트를 통해 소프트웨어의 품질 검증
    * 결함 탐지 및 보고, 수정상태 확인
    * 테스트 실행 및 결과 분석

<br/>

* QA 활동 최적화를 위한 핵심 전략
    1. 초기 참여
    2. 테스트 우선순위 지정
    3. 자동화 테스트 도입
    4. 피드백 루프 강화
    5. 성과 지표 설정
    
<br/>

## 계획  
: 초기 리스크 분석을 바탕으로 명확하고 측정 가능한 품질 목표와 기준 수립

* 요구사항 추적 매트릭스의 중요성  
: 요구사항과 TC 간의 추적 가능성 제공

<br/>

## 요구사항 정의  
: 요구사항 추적 매트릭스를 바탕으로 요구사항을 검토  
품질 기준에 부합 여부와 요구사항 간 중복이나 충돌 검토

> <span style="color:darkgray">**품질 기준 = 비즈니스 목표 + 기술 요구사항**</span>

<br/>

* 요구사항 정의서 검토
    * 기술적인 오류
    * 요구사항의 명확성
    * 구현/테스트 가능 여부 검토

        > <span style="color:darkgray">**웹 브라우저 동작 방식, 웹 브라우저가 어떻게 생성되는지 알아야 요구사항의 오류를 찾을 수 있음**</span>
         
        > <span style="color:darkgray">**e.g.  
        요구사항 : JWT Token을 Local Storage에 저장한다.**  
        >> 저장 : JS 코드로 확인 or 개발자 도구 > Local Sortage에서 확인  
        >> API : JWT Token을 주는지 확인  
        >> 화면 로딩 : 개발자 도구 > 실제로 로그인 화면을 끌어왔는지 확인</span>

<br/>

* 요구사항 변경 관리
    * 요구사항 변경 시 고려사항  
        시스템 성능에 영향을 받는지(DevOps 지식 필요)
        변경사항이 기존 요구사항 문서와 일치하는지
        프로젝트 범위 및 목표와 일치 하는지

<br/>

* 요구사항 관리 툴
    * confluence

<br/>

## 설계
: 요구사항과 설계의 일치 확인(기술 요구사항, 보안, 성능)  
e.g. 성능 > 아키텍처에 따라 성능에 영향이 있음

* 설계 검토
    * 공통  
        * 요구사항 매핑  
        * 설계 문서 검증

    * QA Ops
        * 클라우드레벨(서버 레벨) 아키텍처 검토  
        : DevOps 학습 내용을 바탕으로 구조가 잘 설계되어있나 검토

        * 코드레벨 아키텍처 검토  
        : 모듈이 제대로 생성되었나

<br/>

* 설계 검증  
    * 기능 /비기능적 요구사항의 충족 여부 검증
    e.g. 클라우드 리소스에 따라 성능이 안나올 수도 있음
    품질문제 식별 및 해결방안 제안 필요

<br/>

* Test Case 설계
    * 테스트 가능성 보장 및 실행 준비

<br/>

* 설계 산출물 확인사항
    * 요구사항과 설계 간의 매핑
    * 다이어그램의 일관성 및 정확성
    * 설계 문서의 가독성과 명확성

<br/>

## 구현
* 코드 품질 관리
    * 코드 리뷰(CTO, 7 ~ 10년 개발 경력 보유자)
    * 테스트 가능성, 성능 및 보안성 고려

    > <span style="color:darkgray">**소스 코드 품질 기준 : 가독성, 일관성, 효율성**</span>

* 개발 프로세스 관리
* 테스트 스크립트 제공 또는 자동화 테스트 수행
* CI 과정에서 발견된 결함 관리

<br/>

* 관련 툴
    * Eslint  
    : 코드 가독성 향상, 코드 복잡도 개선, 잠재적 버그, 보안 취약점 분석

    * Jenkins  
    : CI/CD 환경에서 자동 테스트와 자동 배포를 위해 사용  
    유지보수성을 위해 별도의 파일로 만듬  
    리눅스 명령어 필요, http Request를 알아야 함  

    * SonarQube  
    : CI(지속적인 결합) 환경에서 사용하는 테스트 툴

<br/>

## 테스트
: 테스트 범위, 종류, 우선순위 결정

* 테스트 계획 작성  
: 목표, 일정, 리소스, 환경

* Test Case 설계

<!-- * 회귀 테스트 : 결함 수정, 업데이트, 기능 확장 등 코드 변경 시 기존 기능이 정상적으로 작동하는지 확인하는 테스트 -->

* 테스트 환경 설정
    * 테스트 환경 구성 요소 확인
    * 실제 운영 환경과 유사한 환경 구축(staging 서버)
    * 환경 검증 : 환경 설정 오류와 불일치 식별

<!-- * 테스트 종료 기준
    * 결함 수용 기준
    * 테스트 커버리지
    * 테스트 완료율 -->

* 자동화 테스트 툴
    * Selenium : 웹 애플리케이션 자동화
    * Appium : 모바일 앱 테스트 자동화

* 성능 테스트 툴
    * JMeter : 시스템 속도, 안정성, 확장성 평가
    
## 배포
* UAT 
    * UAT계획 및 시나리오 작성 지원
    * 테스트 결과 분석 및 문제 해결 지원

    > <span style="color:darkgray">**UAT, User Acceptance Testing(사용자 수락 테스트)  
    : 최종 사용자가 요구사항을 충족하는지 확인하는 테스트**</span>

<br/>

* 모니터링(QA Ops)
    * 시스템 성능 및 안정성 모니터링
    * 사용자 피드백 수집 및 분석
    * 발견된 이슈 공유 및 수정 확인

<br/>

* 릴리즈 단계 별 활동
    1. 배포 전 : 테스트 결과 보고서 확인
    2. 배포 중 : 품질 기준 충족 여부 검증
    3. 배포 후 : UAT 등 테스트 결과 검토
    4. 배포 완료 : 릴리즈 노트 작성 및 공유

<br/>

* 안정적인 배포와 운영을 위한 활동
    * 배포 중 발생 가능한 리스크 예측 및 대응 계획 수립
    * 배포 후 초기 단계에서의 지속적인 지원 제공

<br/>

## 유지보수
* SW 업데이트 검증  
: 회귀테스트, 업데이트 시뮬레이션 테스트 수행

* 모니터링 툴
    * splunk : 로그 데이터 분석 및 모니터링
    * Nagios : 서버 및 네트워크 모니터링
    * dynatrave : 애플리케이션 성능 모니터링

* 사용자 피드백 모니터링

<br/>

# 버그 vs 오류 vs 결함
* 버그 : 사용자 관점에서 소프트웨어의 문제
    * 원인 : 코딩 실수, 복잡한 시스템, 테스트 부족, 요구사항 정의 오류

* 오류 : 코드 실행 중 발생하는 문제(사람의 문제), 코드 실행 단계에서 발생
    * Syntex error : 문법 오류

* 결함 : 코드의 설계나 논리적 문제, 오류로 인해 발생, 구현/설계 단계에서 발생

<br/>

## 버그의 종류
* 발견 시점에 따른 분류
    * 개발 중 발견된 버그(Development Phase Bug)
    * 배포 후 발견된 버그(Post-Release Bug)

    > <span style="color:darkgray">**트렌드  
    QA가 소스코드 내부에 테스트코드를 삽입하는 등의 방법으로 배포 전 대부분의 버그를 찾고자 함**</span>

* 품질특성 따른 분류
    * 기능 버그(Functional Bug)  
    : 소프트웨어의 핵심 기능이 정상적으로 작동하지 않는 문제  
    시스템의 오작동, 예상과 다른 결과, 동작 오류, 예외처리 등

    * 비기능 버그(Non-Functional Bug)  
    : 성능, 디자인, 사용성과 관련된 문제

<br/>

## 기능 버그
    * 입력 오류
    * 프로세스 오류 : 여러 단계로 이루어진 기능이 중간에서 끊김
    * 계산 오류 : 할인 적용, 이자 계산 등의 연산 오류

## 비기능 버그
* UI/UX 버그 : 웹뷰를 사용하면 해상도에 따라 요소가 짤릴 수 있음

<br/>

* 성능 버그 : 소프트웨어가 느려지거나 비정상적으로 많은 자원을 사용하는 문제
    * 유형
        * 속도 지연  
        : 서버, 데이터베이스, 코드 최적화 부족 등이 원인
        
        * 메모리 및 CPU 과부하  
        : 앱 실행 직후 CPU 과부하, 웹사이트가 오래 실행될수록 메모리 사용량 증가되는 등의 현상

        * 서버 과부하  
        : 부하 증가, 데이터베이스 쿼리 최적화 부족이 주요 원인

    * 예방 방법
        * 트래픽 증가 대비 서버 확장 준비 : Auto Scaling(자동 수평 확장) 적용
        * 정기적인 성능 모니터링
        * 배포 전 성능 테스트 필수 진행

<br/>

* 보안 버그
    * 유형
        * 인증 및 권한 관리 오류  
        : 시스템이 사용자의 계정이나 접근 권한을 제대로 관리하지 못하는 문제
        * 데이터 암호화 오류  
        : 중요 정보가 암호화되지 않고 저장되는 문제  
        (네트워크 전송 중 데이터 암호화가 안됨, 중요 정보가 평문으로 저장)

    * 종류
        * XSS(Cross Side Script)  
        : 공격자가 악성 스크립트를 웹 사이트에 삽입  
        사용자가 컴퓨터 실행 시 악성 스크립트 자동 실행하여 원치않는 기능 작동

        * CSRF(Cross Site Request Forgery, 사용자 간 요청 위조)
        1. 사용자가 웹사이트에 정상 접속 및 로그인
        2. 사용자가 로그인 상태일 때 공격자가 피싱 시도
        3. 사용자가 피싱 링크 클릭 시점에 이미 로그인되어있던 사이트에 패스워드 변경 요청 전송
        4. 공격자가 변경된 패스워드로 접속

        * SQL Injection  
        : 공격자가 입력창을 이용해 악의적인 SQL 명령어를 입력

        * 패킷 스니핑(Packet Sniffing)  
        : 해커가 네트워크에서 주고받는 데이터를 몰래 훔쳐보는 공격

        * 중간자 공격(MITM, Man in the Middle)
        : 공격자가 가짜 웹 사이트 접속 유도 등으로 사용자와 서버 사이에 끼어들어 데이터를 조작하는 공격

        * 디도스
        : 일반적으로 동일 ip로 다수의 요청이 오는 경우 해당 ip가 차단됨  
        디도스는 무작위 ip로 차단을 우회하여 서버나 서비스, 네트워크의 정상적인 트래픽을 방해하는 공격

    * 예방 방법
        * 침투 테스트(Penetration Testing)
        * 취약점 스캐닝(Vulnerability Scanning)
        : OWASP, metasploit, NMAP 등을 사용

<br/>

* 호환성 버그(Compatibility Bug)
    * 발생 원인
        * 브라우저마다 지원하는 JS 버전과 SCC 기능이 다름
        * 렌더링 방식, HW 성능 차이
        * API 및 라이브러리 변경 > 업데이트 후 기존 기능이 호환되지 않을 수 있음

    * 예방 방법
        * 표준 기술 사용
        * 반응형 디자인 적용
        * OS/브라우저별 예외 처리
        * 코드 리뷰
        * 단위테스트 실행

> <span style="color:darkgray">**다양한 브라우저, 운영체제, 해상도 및 디바이스, 네트워크 환경(속도)에서 테스트 필요  
BrowerStack : 다양한 브라우저, 운영체제에서 웹사이트 테스트 가능**</span>

<br/>

## 버그 리포트 구성
* 제목(Title)

* 우선순위/심각도(Priority / Severity)
    * 우선순위 : 긴급, 높음, 보통, 낮음
    * 심각도 : Critical, Major, Minor, Trivial

* 담당자(Assignee)
    * 버그 수정 담당자

* 환경(Environment)
    * 버전(앱 버전, 브라우저 버전, OS 버전)
    * 기기 정보
    * 네트워크 상태
    * 테스트 계정

* 설명(Description)
    * 재현 단계(Steps to Reproduce)
    * 예상 결과(Expected Result)
    * 실제 결과(Actual Result)

* 첨부 자료(Attachments/Evidence)
    * 스크린샷, 동영상, 로그, 콘솔 출력

* 레이블/태그(Labels/Tags)
    * 모듈명, 플랫폼(iOS/Android/Web), 팀명 등

## Test Case

* 오류를 사전에 발견하여 수정 비용 절감
* 테스트 자동화 및 반복 검증 가능
* 새로운 개발자가 테스트를 쉽게 이해할 수 있도록 도움

* 구성요소
    * TestCase ID : 자동화 테스트 실행 시 특정 테스트를 선택 가능
    * Requirement ID
    * Title

    * Test Item(Test Object) : 테스트하는 기능, 시스템, 모듈을 명확하게 정의
    * Test Input(Test Data) : 입력 데이터, 엣지 케이스도 고려해야 함
    * Test Environment : OS, Browser, 네트워크 조건 등
    * Pre-Condition : 사전 조건
    * Steps : 테스트 절차

    * Expected Result : 기대 결과
    * Response body : 자동화 테스트 스크립트 작성을 위해 표기
    * Request body : API 명세에 기록
    * Actual Result : 실제 결과 + 재현 빈도
    * Test Status : Pass/Fail 상태

# API 테스트
: UI 테스트는 브라우저를 통한 최종 동작을 테스트하기 때문에, 실제 API 요청이 일어났는지는 알 수 있지만 모든 API의 세부 동작을 보장하지는 않음  
따라서 백엔드의 응답을 정확히 확인하기 위해 API 테스트 수행  
(비즈니스 로직, 데이터 처리 테스트)

## API테스트의 종류
    * 기능 테스트 : 명세에 맞게 개발되었는지 확인
    * 성능 테스트 : 속도 확인
    * 부하 테스트
    * 보안 테스트 : 취약점 확인, 쿠키/http only로 잘 오는지 확인
    * 신뢰성 테스트 : 오류처리 확인

## API 테스트 항목
    1. 데이터 유효성 검사
        * 필수조건일경우 누락이 있는지
        * 옵셔널인경우 기본값 설정이 되는지
        * 경계값 테스트
        * 명세에 있는 키값에 대한 유효성 검사
        * 잘못된 타입의 값 전달

    2. 로그인 확인 검사 
        * 토큰과 쿠키가 브라우저에 저장되는지
        * 토큰과 쿠키 없이 로그인 가능한지
        * 토큰과 쿠키의 만료시간이 정상적으로 동작하는지
        * 로그아웃(만료) 상태에서 토큰/쿠키로 접근 시 방어가 되는지
        * 비유효한 토큰 사용 > 토큰 위변조 방어 확인

    3. 기능 테스트 : CRUD 후 정상적으로 데이터가 조회되는지 확인하는 것
        * 생성, 업데이트, 삭제 기능 : TC와 무관하게 조회 필수
        * 조회 : 필터링 확인, 누락 확인, 권한이 없는 다른 API에 접근(조회) 가능한지 확인
        * 응답값이 명세와 일치하는지 확인(키, 데이터 타입, )
        * 추가 기능 테스트

    4. 에러처리
        * 상황에 맞는 Status Code가 나오는지 확인
        * 에러 메세지가 올바른지 확인

    5. 반응속도
    6. 보안
        * SQL injection

<br/>

# 성능 테스트
## 성능테스트 종류
* 내구성 테스트(Soak Test)  
    : 정상적인 부하 상태를 **장시간** 유지하며 시스템의 안정성 및 잠재적 문제를 확인  
    메모리 누수, DB 커넥션 풀 문제, 디스크 공간 부족 확인

    > <span style="color:darkgray">**DB Connection  
    : 애플리케이션과 DB서버의 통신을 위해 네트워크를 연결하는 것  
    동시에 처리할 수 있는 연결 세션의 수가 제한되어있음  
    <br/>
    DB Connection Pool  
    : DB 연결을 미리 여러 개 생성해놓고, 필요할때마다 해당 연결을 재사용하는 기술**</span>

* 용량 테스트(Capacity Test)  
    : 특정 성능 목표를 만족하면서 시스템이 처리할 수 있는 최대 사용자 수 또는 트랜잭션 양을 파악  
    현재 시스템 구성의 최대 용량, 향후 시스템 확장 시점 예측  
    부하테스트에서 확인 가능하기때문에 실무에서는 별도 진행하지는 않는다.

* 부하 테스트(Load Test)  
    : 예상되는 정상적인 최대 부하상태에서 시스템의 성능을 측정하고 검증  
    비기능 요구사항(NFR) 만족 확인, 병목 지점 초기 식별

    > <span style="color:darkgray">**SPA는 일반적으로 클라이언트 렌더링을 하지만, SSR(서버 사이드 렌더링) 기반 SPA(Nuxt, Next.js 등)의 경우에는 렌더링 서버에 부하가 걸리므로 부하 테스트 필요함  
    반면에 순수 CSR 방식에서는 정적 파일을 제공하는 서버에만 요청이 가므로 서버 부하는 상대적으로 적음**</span>

* 스트레스 테스트(Stress Test)  
    : 예상되는 정상적인 최대 부하를 초과했을 때 시스템의 성능을 측정하고 검증  
    시스템 안정성, 최대 처리 용량, 장애 시 데이터 정합성, 자동 복구 메커니즘 확인

* 스파이크 테스트(Spike Test)  
    : 순간적으로 급증하는 부하에 시스템의 반응과 복구 확인  
    시스템의 순간적인 부하 대응 능력, 자동 확장(auto-scaling), 부하 해소 후 정상 상태 복구 시간 확인

<br/>

## 성능 지표(KPI)
* 사용자 관점
    * 응답시간(Response Time) : 평균, 백분위수 확인  
        > <span style="color:darkgray">**평균(Average) : 전체 응답 시간의 산술 평균  
        백분위수(Percentile) : 특정 비율의 요청이 완료된 시간**</span>

* 시스템 관점
    * 처리량(Throughput) : 일반적으로 부하가 증가하면 처리량도 증가, Saturation Point(임계점) 이후에는 정체되거나 감소함
        * TPS, Transactions Per Second : 초당 처리된 비즈니스 단위의 트랜잭션 수
        * RPS, Requests Per Second : 초당 처리된 http 요청 수

* 자원 관점
    * 동시 사용자 수(Concurrent Users)
    * 자원 사용률(Resource Utilization) : 병목 지점 식별
        * CPU 사용률
        * 메모리 사용률 : RAM 사용률이 높으면 OOM 발생 가능, GC 부담 증가, 따라서 OOM이 발생하는지, GC 변화량이 일정한지를 집중적으로 확인

            > <span style="color:darkgray">**OOM : Out Of Memory, 허용 용량 초과  
            GC : Garbage Collection, 동적으로 할당한 메모리 중 필요없어진 영역을 해제하는 기능**</span>

        * 네트워크 I/O : 네트워크 대역폭

            > <span style="color:darkgray">**클라우드에서 제공하는 디스크는 관리형 스토리로, 일정 수준의 IOPS와 처리량이 보장됨  
            따라서 일반적으로 디스크I/O 성능이 중요하지 않음**</span>

        * 디스크 I/O : 디스크 읽기/쓰기 활동량

            > <span style="color:darkgray">**클라우드 환경은 기본적으로 고속 네트워크를 갖추어 네트워크 병목 가능성이 낮음  
            따라서 단일 시스템에서는 네트워크 I/O 성능이 중요하지 않음**</span>

* 안정성 관점
    * 에러율(Error Rate) : 에러가 발생되는 요청과 발생되는 에러의 종류(http 상태코드) 확인 필요
    * 가용성 >> CPU, 메모리가 꽉찼을때 임시로 사용 가능하도록 가용성 확보해야함

<br/>

## 테스트 환경 구축
: 독립된 테스트 환경 확보, 데이터 보안 확인 및 모니터링 시스템 구축

* 하드웨어
    * CPU 코어 수
    * 메모리 크기
    * 디스크 종류(SSD/HDD)
    * 네트워크 대역폭 등

* 소프트웨어
    * OS
    * 웹서버 : Nginx, Apache
    * WAS : Tomcat, JBoss
    * DB : MySQL, Oracle
    * 미들웨어 : Kafka, Redis
    * 라이브러리 버전 등

* 시스템 설정값
    * OS 커널 파라미터
    * WAS 스레드 풀 설정
    * 튜닝 파라미터 등

* 테스트 데이터
    * 규모와 다양성을 고려
    * 특정 시나리오 고려
    * 민감 정보 마스킹, 익명화 처리
    * HTTP 요청을 위한 검색어, Body값

* 네트워크
    * Latency(지연 시간) 시뮬레이션
    * Bandwidth(대역폭) 제한

* 모니터링 : 아키텍처나 구조 설계의 문제로 병목 지점이 생기는지 진단
    * 대시보드 구성

<br/>

## 시나리오 설계
* 워크로드 모델
: 정확한 병목 지점 식별 및 효과적인 튜닝 방향 제시를 위해 사용
    > <span style="color:darkgray">**워크로드(Workload) : 특정 기간 동안 시스템에 가해지는 부하의 양과 특성  
    워크로드 모델링(Workload Modeling) : 워크로드를 운영환경과 유사하게 재현하기 위해 모델을 만드는 과정**</span>

    * 사용자 패턴 분석 방법
        * APM (Application Performance Management) 데이터 활용 : new relic, Data Dog 등
        * 웹/앱 분석도구 사용 : Google Analytics, Amplitude, Mixpanel 등
        * 웹서버 Access Log 분석도구 사용 : GoAccess, ELK Stack 등

            > <span style="color:darkgray">**ELK Stack 구성 
            -Elasticsearch : 오픈소스 검색엔진
            -Logstash : 데이터를 동적으로 수집, 전환, 전송하는 엔진 오픈소스
            -Kibana : 데이터 시각화 툴**</span>

<br/>

* 워크로드 모델링의 주요 요소
    * 주요 비즈니스 시나리오 식별  
    : 빈도, 중요도, 자원 소모량 기준

    * 동시 사용자수 정의  
    : 로그/분석 도구 데이터 기반, 비즈니스 목표 기반 설정

    * 처리량(Throughput) 목표 설정   
    : 부하 테스트의 성공/실패 기준, 용량 테스트의 목표치 설정

    * Think Time 정의  
    : 현실성 부여를 위해 다음 동작을 시작하기까지 대기시간 설정

    * Pacing 정의  
    : 목표 처리량 달성을 위해 다음 시나리오를 시작하기까지의 간격 설정

    * 시나리오 믹스 결정  
    : 실제 운영 환경의 다양한 사용자 행동 패턴을 반영하여 전체 부하에서 각 시나리오가 차지하는 비율 결정

<br/>

## 결과 분석 및 리포팅
* 주요 분석 내용
    * 테스트 목표(NFR) 달성 여부 판단
    * 부하 증가에 따른 성능 지표 추이 분석
    * 병목 구간 식별
    * 서버 자원 사용률과 성능 지표 간의 상관관계 분석

* 리포팅 : 주요 결과, 발견된 문제점, 개선 권고 사항 포함

## 모니터링
: 테스트 실행 중 시스템 자원 사용률, APM(애플리케이션 성능 관리) 지표 실시간 확인

* 모니터링 대상
    * 응답 시간, TPS, 에러율
    * 서버 자원(OS Level)
    * CPU, 메모리, 디스크 I/O, 네트워크 I/O
    * APM(애플리케이션 성능 관리) 지표
    * 트랜잭션별 상세 응답 시간, 메소드 레벨 프로파일링, DB 쿼리 분석, 외부 호출
    * Active Session, Lock 현황, Slow Query(Low Query)

* 모니터링 도구
    * 오픈소스
        * Prometheus + Grafana : 생성된 클래스 수, GC 크기 등 각종 모니터링 지표를 수집하여 저장하고 검색할 수 있는 프로메테우스를 그라파나로 시각화
        * Zabbix: 에이전트 기반 통합 모니터링 솔루션
        * Nagios: 시스템, 네트워크 모니터링
        
    * 상용 솔루션
        * Datadog : SaaS 기반 통합 모니터링 플랫폼
        * New Relic : SaaS 기반 APM 및 인프라 모니터링
        * Dynatrace : AI 기반 자동화된 모니터링 및 분석

<br/>

## APM(Application Performance Management)  
: 애플리케이션의 성능을 모니터링하는 프로세스

* 추적 지표
    * CPU 사용량
    * 응답 시간 : 허용 가능한 기준 성능과 비교하여 응답시간이 임계값 미만인 경우 알림
    * 오류율 : 사전 정의된 파라미터값을 기준으로 알림 제공
    * 트랜잭션 추적 : 사용 가능한 함수 호출, 외부 호출, DB 호출 등 단일 트랜잭션 모니터링
    * 인스턴스 : 실행 중인 서버 또는 애플리케이션 인스턴스의 수 모니터링
    * 요청 수 : 비정삭적인 요청 감지
    * 가동시간

* APM 솔루션
    * 오픈 소스
        * Pinpoint: Bytecode Instrumentation 기반 Java APM
        * Scouter: Java, Python 등 지원
        * Zipkin: Twitter에서 개발한 분산 추적 시스템
        * Jaeger: Uber에서 개발한 분산 추적 시스템
        
    * 상용: Datadog APM, New Relic APM, Dynatrace 등

> <span style="color:darkgray">**APM 솔루션 vs 모니터링 도구  
APM 솔루션 : 애플리케이션의 성능 및 사용자 경험 중심  
일반 모니터링 도구 : 시스템, 서버, 네트워크 등 인프라 중심**</span>