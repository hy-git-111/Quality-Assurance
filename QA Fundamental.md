[마크다운 가이드] https://www.markdownguide.org/cheat-sheet/

# SW 품질
: 기능, 비기능, 기타 도메인 요구사항 등을 충족하는 정도

<br/>

# SW 품질의 주요 요소

* 기능 적합성
* 성능 효율성
* 호환성
* 사용성
* 신뢰성
* 보안성
* 유지보수성
* 이식성

<br/>

# SW 검증 항목

* 기능성
* 성능
* 보안
* 사용성

<br/>

# SW 품질 향상을 위한 방법

* 코드 리뷰  
    * 코드 검토를 통해 오류를 사전에 제거
        > <span style="color:darkgray">**일반적으로 기업에서는 개발자들이 담당**</span>

* 테스팅
    * 기능, 성능, 보안을 포함한 다양한 테스트 실행
    * 서버 테스트는 개발자가 거의 수행함   

* 품질 관리 프로세스
    * ISO/IEC 25010 국제 표준 준수  

* 사용자 피드백 반영
    * 실 사용자의 의견을 통해 품질 개선

<br/>

# 품질 향상을 위한 업무

* Testing
    * 요구사항 충족 확인을 위해 설계된 활동

* QC, Quality Control
    * 결함 탐지, 수정을 위해 테스트 및 제품 품질 평가
    * 교정적(문제 발생 후 수정)

* QA, Quality Assurance  
    * 소프트웨어 개발 과정 전반에서 품질 목표를 설정하고 이를 달성하기 위한 활동
    * 프로세스 설계, 표준 준수 검토, 절차 개선
    * CL, 테스트 시나리오 작성 업무
    * 예방적

* QM, Quality Management
    * 조직 차원에서 제품 품질 보장을 위한 전체 프로세스와 정책, 절차 수립 및 실행

        > <span style="color:darkgray">**TC 설계 방식  
            개발자 : 기능 기반 설계  
            QA : 요구사항 기반 설계**</span>

<br/>

# SW Testing 7가지 원리

* 테스트는 결함의 존재를 밝히는 활동이다.
* 오류는 어디에나 존재한다.
* 완벽한 테스팅은 불가능하다.
* 테스트는 초기에 해야한다.
* 파레토의 법칙(전체 결과의 80%가 전체 원인의 20%에서 발생한다.)
* 테스팅은 정황에 따라 다르다.
* 오류 부재의 궤변

<br/>

# 테스트 기술의 발전 단계

1. 디버깅 위주의 시대
    * 테스트와 디버깅의 구분이 없음  
    * 테스트를 "결함 제거를 돕는 활동"으로 인식

2. 증명 위주의 시대
    * 소프트웨어가 요구사항을 만족시키는지 증명  
    * 디버깅 활동과 결함 발견, 위치 파악, 수정 과정과 연계됨

3. 파괴 위주의 시대
    * 테스트를 결함을 발견하는 활동으로 구분
    * 디버깅을 결함의 위치를 파악하고 수정하는 활동으로 인식

4. 평가 위주의 시대
    * 소프트웨어 개발 프로세스 전반에 테스트가 흡수되고 통합된 상태
    * 검토 활동의 가치가 인식됨
    * 테스트 개념이 확장됨
    * 요구사항, 디자인, 구현과정 등 개발 활동 전반에서 결함 발견

5. 예방 위주의 시대
    * CMM, TMM 레벨 5 최적화 단계 반영
    * 요구사항, 디자인, 구현과정 등 개발 활동 전반에서 결함 발견

<br/>

# 소프트웨어 테스트 수명주기(STLC)

## 소프트웨어 테스트 단계

1. 요구사항 분석
    * 기능 명세서, 기획서 등 명세를 바탕으로 요구사항 검토 및 테스트 조건 도출

        > <span style="color:darkgray">**개발팀은 요구사항 정의서를 통해 테스트 대상이 정의됨   
        이후 개발작업에서 테스트를 고려하여 설계함  
        따라서 개발에서는 별도의 계획이나 분석이 필요하지 않음**</span>

2. 테스트 계획  
    * 목표와 전략 설정    
    * 자원 및 일정 관리
    * 프로젝트 리스크 평가 및 우선순위 선정이 필수적임

3. 테스트 설계
    * 테스트 분석을 바탕으로 Test Case, Test Data 구체화

4. 테스트 환경 준비

5. 테스트 실행
    * 소프트웨어의 안정성과 신뢰성을 확보하는 핵심 단계
    * 예상 결과와 실제 결과 비교, 확인 테스트 수행

        > <span style="color:darkgray">**개발에서는 JUnit 등의 툴을 사용하여 코드 작성과 동시에 테스트 진행**</span>

6. 테스트 종료
    * 테스트 종료 기준 충족 여부 확인
    * 최종 보고서 작성
    * 회고를 통해 프로세스의 효율성/효과성을 평가하고 개선 방안 도출

<br/>

## 요구사항 분석

* 요구사항의 종류
    * 기능 요구사항  
        * 기능에 대한 우선순위가 중요함
        * 기능 정의서 : 소프트웨어가 수행해야하는 것에 대한 명세(기능, 입력, 출력 정의)

    * 비기능 요구사항  
        * 시스템 성능, 보안, 확장성 등 품질 특성 정의

    * 도메인 요구사항
        * 특정 산업이나  비즈니스 도메인에 특화된 요구사항
        * 산업 규정, 관련 법률 등

            > <span style="color:darkgray">**기능 요구사항을 받으면  
            보안 > 프레임워크 > 자원 > 도메인 순으로 고려하여 개발 작업 진행**</span>

<br/>

## 테스트 계획

### 테스트 목표 수립

* 결함 발견, 요구사항 충족 여부 확인, 사용자 만족도 향상 등을 포함함  
* 코어기능(비즈니스 핵심 기능) > 보안 순으로 우선순위가 높음

<br/>

### 테스트 전략 수립

* 전략 수립 유형
    * 위험 기반 접근법
    : 주요 리스크를 우선적으로 테스트

    * 요구사항 기반 접근법
    : 소프트웨어 요구사항에 따라 테스트 설계 

    * 탐색적 접근법
    : 정해진 케이스 외에도 결함 가능성이 높은 영역 탐색

    * 자동화 접근법
    : 반복적인 작업을 자동화하여 효율성 극대화

        * 테스트 스크립트 툴  
            * Java  
            * JavaScript
            * Python

        * 테스트 도구
            * Selenium
            : 웹 애플리케이션과 상호작용하여 브라우저 직접 조작
            * JMeter
            : 성능, 부하 테스트, 웹 애플리케이션, 서버, DB, API 성능 테스트
            * Postman, Appium

<br/>
       
* 리스크 평가 단계
    1. 리스크 식별
        : 결함, 성능, 일정, 자원 등

    2. 리스크 평가
        : Impact(영향도), Likelihood(발생 가능성) 판단

    3. 대응 방안 수립

    4. 리스크 모니터링

* 리스크 대처 방안  
    : 회피, 감소, 수용, 이전(타부서나 외부 업체와 분담)

<br/>

### 테스트 자원 분배 및 일정 계획

* 테스트 범위와 목표에 따라 자원을 사전에 정의
    * 브룩스의 법칙(Brook's Law)  
    : 늦어진 프로젝트에 인력을 추가하면 프로젝트가 더 늦어진다.

        > <span style="color:darkgray">**병렬화의 한계 발생  
        커뮤니케이션 복잡성 증가, 훈련 비용, 인수인계 시간 필요 등**</span>

<br/>

* 일정 계획의 요소
    * 테스트 일정 설정  
    : 시작 및 종료 시점 정의

    * 작업 분할  
    : 각 테스트 간계의 소요시간 예측 및 분배

    * 리스크 관리  
    : 여유 시간 설정

    * 의사소통 계획  
    : 일정 공유, 협업을 위한 체계 마련

<br/>

## 테스트 설계

* Test Condition
    * 검증 상황, 입력값, 정상동작 판단 기준
    * 테스트 우선순위 선정에 활용됨

* Test Condition 도출 순서
    1. 요구사항 분석
    2. 리스크가 높은 부분 확인

        > <span style="color:darkgray">**코어 기능 > 복잡성이 높음  
        코어 기능 > 구현에 시간 자원이 많이 소요  
        따라서 코어 기능의 리스크가 높을 확률이 큼!**</span>

    3. 사용자 입장에서의 도출
    4. 최대/최솟값 검증
        
* Test Case
    * 구성
        : 분류, 입력값, 수행 절차, 기대 결과, 수행 결과

* Test Data
    * 테스트 실행 시 필요한 입력값과 환경을 구성하는 자료
        * 실제 운영 데이터
        * 모의 데이터(보안 이슈가 있는 경우)
        * 경계값
        * 비정상 데이터

<br/>

## 테스트 환경 준비

* 테스트 환경의 종류(각 환경마다 사용하는 DB가 다름)
    * Local Server     
    : 개발자 PC에 설치된 개발 및 테스트 환경

    * Dev Server  
    : "서버" 개발 환경, 기능 중심의 코드 블록을 통합하여 테스트 수행

    * Staging Server  
    : 운영과 동일한 환경  
    운영에서 사용하는 DB를 사용하여 테스트 진행(비기능 테스트 포함)

    * Production Server      
    : 운영 환경, 라이브 서버, 실제 서버를 위한 운영 환경

<br/>

* 테스트 환경 설정의 주요 요소
    * 하드웨어 설정  
    : CPU, 메모리, 디스크 공간 등

    * 소프트웨어 구성  
    : OS, DB, App 설치 및 설정

    * 네트워크 환경  
    : 네트워크 속도와 대역폭, 지연 시간 등을 실제 환경과 비슷하게 설정하여 반영  
    온프레미스(On-premise)/클라우드 서비스 사용 고려
         
    * 테스트 데이터 준비

    * 테스트 환경 최적화

<br/>

## 테스트 실행

* 테스트 실행 방법론의 유형
    * 수동 테스트  
    : 테스터가 직접 케이스 수행

    * 자동화 테스트  
    : 반복적이고 시간이 많이 소요되는 작업을 자동화 도구로 실행  
    e.g. 성능 모니터링, 리그레션 테스트

    * 탐색적 테스트  
    : 경험과 직관을 기반으로 수행

    * 스모크 테스트  
    : 주요 기능이 정상적으로 동작하는지 확인하는 테스트  
    자동화를 통해 초기 테스트 단계에서 일정 수준의 커버리지 확보 가능

<br/>

* 결함 기록
    * 품질 보증 프로세스의 핵심 단계 중 하나
    * 우선순위, 심각도, 해결을 위한 복잡도에 따라 결함이 분류됨
    * 항목  
    : ID, 요약, 사전 조건, 재현 단계, 우선순위 및 심각성

<br/>

* 테스트 모니터링 및 제어
    * 테스트 진행 현황 추적  
    * 테스트 상태 추적 지표
        * 테스트 수행률
        * 테스트 커버리지
        * 결함 분포(기능/성능/UI 결함 등)
        * 결함 수정 상태
        * 일정 준수율

    > <span style="color:darkgray">**테스트 커버리지가 90%이고,  
    나머지 10% 기능의 우선순위가 낮다면 잘 수행된 테스트라고 평가 가능함  
    (평균 85% ~ 90%)**</span>
    
<br/>

* 테스트 결과 분석
    * 결함 데이터 분석
    : 결함 수, 종류, 심각도

    * 테스트 커버리지 평가
    : 테스트 누락 확인

    * 재테스트 수행 여부 평가

    * 품질 개선 제안
    : 추가 테스트 제안, 코드 수정

    * 최종 평가
    : 소프트웨어가 기대 수준에 적합한지 평가

<br/>

* 테스트 결과 보고서
    * 구성
    : 테스트 요약, 결함 현황, 테스트 상태, 추천 사항(품질 개선을 위한 QA 의견)

<br/>

## 테스트 종료
* 테스트 종료 평가 기준
    1. 기능 기반
        * 제품 초기에 중요한 종료 기준
        * 주요 기능의 정상 동작 여부 평가
        * 핵심 기능이 오류 없이 동작하면 테스트 종료
    
    2. 결함
        * 잔여 결함의 심각도 고려

    3. 커버리지

    4. 시간
        * 기간 내 목표한 검증이 완료되었는지 평가하여 테스트 종료

    5. 리스크
        * 리스크 평가 결과를 바탕으로 테스트 종료 여부 결정

<br/>

* 테스트 완료 보고서
    * 테스트 범위, 결함, 테스트 상태, 개선 사항 포함

<br/>

* 회고
    * 테스트 프로세스의 효율성과 효과성 증진
    * 향후 프로젝트에 적용할 교훈 도출
    * 성과 평가, 문제 분석, 지식 공유, 지속적인 개선

    > IT업계에서 중요한 요소!

<br/>

# 테스트 방식의 분류

## 정적/동적 테스팅
* 정적 테스팅
    * 리뷰
    * 정적 분석

* 동적 테스팅
    * 블랙박스 테스트  
    : 명세 기반, 소스코드를 참고하지 않고 TC 설계

    * 화이트박스 테스트  
    : 구조 기반, 소스코드와 내부 구조를 바탕으로 TC 설계

## 테스트 레벨
* 단위 테스트(Unit Test)
    * 함수, 메서드 단위의 단일 기능 테스트
        * 함수 : 특정 작업을 수행하는 코드, 재사용과 가독성 향상을 위해 사용(호출 객체 X)
        * 메서드 : 클래스 내부에 정의한 함수(호출 객체 O)

    * 독립적 TC 작성을 통해 다른 테스트에 영향을 받지 않도록 수행
    * 유지보수 단계에서는 코드가 변경될 떄 TC를 함께 수정해 오류 방지

<br/>

* 통합 테스트(Itegration Test)
    * 모듈 간 연결 확인으로 시스템 전체의 안정성 확보
    * 통합테스트 전략
        * 하향식 접근법(Top-down)
        * 상향식 접근법(Bottom-up)
        * 샌드위치 접근법(Sandwich)
        : 시스템을 각 계층으로 나누어 개발함 > 계층별로 나누어 테스트 수행
        * 비 점진적 전략(Big Band)

    * 통합 테스트 주요 활동
        * 인터페이스 검증  
        : 모듈 간 데이터의 전달/교환 확인
        API 호출 확인
        
        * 통합 시나리오 설계  
        : 전체 기능 흐름을 따라 테스트를 단계적으로 수행할 수 있도록 설계  
        코드단에서는 데이터를 주는 순서 지정

        * API 테스트  
        : 기능 간 API 호출(요청과 응답)이 올바르게 이루어지는지 검증
        잘못된 데이터를 받으면 오류를 인지할 수 있는지도 확인 필요

        * 결과 분석  
        : 각 모듈이 서로 연결된 상태에서 제대로 작동하는지 확인하고 오류를 찾아냄

<br/>

* 시스템 테스트(System Test)
    * SW를 하나의 완성된 시스템으로 보고, 모든 기능과 성능이 정상적으로 작동하는지 확인
    * 기능적 요구사항과 비기능적 요구사항 모두를 점검

<br/>

* 인수 테스트(Acceptance Test)
    * 비즈니스 관점에서의 동작 확인
        * 알파 테스트
        : 소규모 그룹의 의견 수집

        * 베타 테스트
        : 공개적으로 발표되는 경우가 많음
        평균 6개월 정도 지속

<br/>

* End to End 테스트(E2E Test)  
    * 웹 통신을 기반으로한 테스트  
    * 기능 관점에서, 시스템의 시작부터 끝까지 전체 흐름을 확인  

[추가 학습 자료] https://hyeon9mak.github.io/acceptance-test-vs-e2e-test/

<br/>

## 테스트 유형
* 기능 테스트
    * 입력값과 출력값 비교
    * 비정상 시나리오를 포함한 시뮬레이션 진행

<br/>

* 비기능 테스트
    * 성능 테스트  
    : 응답 시간, 처리량, 자원 사용량 측정

    * 부하 테스트  
    : 유저의 수와 초당 API 요청 등을 증가시켜 시스템 내구성을 테스트하고 결과를 모니터링  
    "애플리케이션의 한계"를 찾는 테스트

    * 스트레스 테스트  
    : 시스템이 과부하 상태일 때 서버가 다운되지 않고 에러를 처리하여, 시스템이 안정적으로 복구가 되는지 확인

    * 복구 테스트  
     : 서버 다운 후 자동 복구가 되는지 확인

        <span style="color:darkgray">**스트레스 테스트와 복구 테스트는 결이 비슷해서 함께 진행된다**</span>

    * 보안 테스트 : 보안 공격으로 부터 안전한지 확인

    * 사용성 테스트 : 인터페이스가 직관적이고 사용하기 편한지 확인

[추가 학습 자료] https://seongwon.dev/ETC/20220919-%EC%84%B1%EB%8A%A5%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%B6%80%ED%95%98%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%8A%A4%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%9E%80/

<br/>

* 구조적 테스트
    * 로직의 흐름을 기반으로 오류 확인
    * 주로 조건문과 반복문의 실행으로 논리적 결함 발견

<br/>

* 회귀 테스트
    * 기능의 확장 등으로 인한 코드 변경 후, 기존 기능이 제대로 작동하는지 확인
    * 사이드 이펙트의 영향이 있는지 확인

<br/>

* 탐색적 테스트
    * 새로운 기능이 추가되거나 초기 단계에서 효과적
    * 예기치 못한 결함을 빠르게 해결할 수 있음

<br/>

* 유효성 테스트(Validation Testing)
    * 올바른 제품을 만들었는지 확인
    * 개발 후반, 실제 사용 환경에서 수행
    * SW가 요구사항을 충족하는지 확인
    * 블랙박스 테스트 기법 사용

<br/>

* 확인 테스트(Verification Testing)
    * 제품을 올바르게 만들었는지 확인
    * SW가 정확히 구현되었는지 확인
    * 개발 초반, 설계 및 구현 단계에서 수행
    * 화이트박스 테스트 기법 사용

<br/>

# 테스트 설계 기법
* 테스트 설계 기법 선택 기준
    * SW 복잡성 고려
    
        > <span style="color:darkgray">**복잡성 관리가 중요한 시스템에서는  
        코드와 구조를 분석하는 기법이 유용함**</span>
    
    * 목표 및 리스크 파악
    * 리소스 평가
    * 요구사항 명확성 평가

## 명세 기반 테스트
* 동등 분할
    * 입력값을 분류하여 각 구간별 대표값을 테스트 입력값으로 사용
    * 입력값 구조가 단순할때 사용
    * 복잡한 관계 검증에 부적합

* 경계값 분석
    * 입력값의 경계값을 중심으로 테스트
    * 복잡한 시스템에 부적합

* 상태전이
    * 특정 입력에 따라 상태가 어떻게 바뀌는지를 확인
    * 데이터 흐름을 인식하여 분기 오류(논리적 오류)를 찾을 수 있음

* 결정 테이블
    * 입력 조건이 다양할 때 사용

## 구조 기반 테스트
: 프로그램 설계도를 바탕으로 논리적 오류 확인

* 제어 흐름 기반
    * 조건문, 반복문 등을 기반으로 테스트 설계
    * 모든 실행 경로가 한 번 이상 테스트되어야 함

* 데이터 흐름 기반
    * 변수의 정의와 사용 간의 관계를 검증
    * 변수가 올바르게 초기화되고, 사용 후 예상대로 변경되지 않았는지 확인

    잘못된 변수 선언의 예
    ```
    # Javascript 변수 선언 예시

    let a; // 초기화 x(= 초기값 지정 x), 코드 실행 시 오류 발생
    ```

    변수가 올바르게 초기화가 되지 않은 예
    ```
    # 변수명은 수치를 뜻하지만, 값의 형식은 숫자가 아닌 경우

    amount = "문자열"
    ```

    데이터 일관성이 보장되지 못한 예
    ```
    # 금액의 합계를 구하는 코드

    amount = 1000   # 숫자
    name = "김혜영" # 문자열
    amount + name = total   # 숫자와 문자열 더하기 연산 수행
    ```

* 코드 커버리지
    * Line Coverage
    : 모든 구문을 한 번 이상 실행

    * Branch Coverage
    : 모든 분기 "결과값"이 한번씩 나오도록 테스트

    * Condition Coverage
    : 조건식의 "개별 조건"이 참/거짓이 한 번씩 나오도록 테스트

    * 다중 조건 커버리지
    : 다중 조건문과 반복문이 포함되었을 때, 모든 조건 조합의 경로 테스트

    * Path Coverage
    : 모든 경로 테스트
<br/>

## 경험 기반 테스트
: 테스터의 숙련도와 결함 탐지 속도 비례

* 탐색적 테스트
    * 경험과 직관 활용

* 오류 추정
    * 과거 경험과 시스템 지식을 바탕으로 결함을 예측하여 테스트
    * 새로운 유형의 오류 확인이 어려움

* 체크리스트 기반 테스트
    * 주요 기능, 요구사항, 표준 규격 등의 테스트에 사용
    * 예외상황 탐지가 어려움

<br/>

